# VUE.js

#### 什么是Vue.js

###### Vue.js是目前最火的前端框架，React是最流行的一个前端框架（React除了开发网站，还可以开发手机App，Vue语法也可以用来开发手机app，需要借助于Weex）

###### Vue.js是前端主流框架之一，和Augular. js、React.js一起，并成为前端三大主流框架！

###### Vue.js是一套构建用户界面的框架，**只关注图层，它不仅易于上手，还便于与第三方库或既有项目整合。(Vue有配套的第三方类库，可以整合起来做大型项目的开发)

#### 为什么要学习流行框架

###### 企业为了提高开发效率；在企业中，时间就是效率，效率就是金钱；企业中，使用框架，能够提高开发效率

###### 提高开发效率的发展历程：原生JS —> jQuery之类的库 —>前端模板引擎 —>Anglar.js / Vue.js

###### 在Vue中，一个核心的概念，就是让用户不在操作DOM元素，解放了用户的双手，让程序员可以更多的时间去关注业务逻辑

#### Node（后端）中的MVC与前端中的MVVM之间的区别

###### MVC 是后端的分层开发概念

###### MVVM是前端视图层的概念，主要关注于视图层分离，也就是说MVVM把前端的视图层，分为了 三部分 Model View VM ViewModel

<img src="C:\Users\彭\AppData\Roaming\Typora\typora-user-images\image-20191206215212296.png" alt="image-20191206215212296"  />

#### 指令

##### 本质就是自定义属性，Vue中	都是以v-开头

##### v-cloak 

######  防止页面加载时出现闪烁问题

```
<style>
    [v-cloak] {
        display: none;
    }
</style>
<body>
    
    <div id="app">
        <p v-cloak>{{msg}}</p>
    </div>

</body>
<script src="./vue.js"></script>
<script>
    var app = new Vue({
        el: '#app',
        data: {
            msg: 'Hello world'
        }
    });
</script>
```

#####  v-text

###### v-text指令用于将数据填充到标签中，作用于插值表达式类似，但是没有闪动问题

###### 如果数据中有HTML标签会将html标签一并输出

###### 注意：此处为单向绑定，数据对象上的值改变，插值会发生变化；但是当插值发生变化并不会影响数据对象的值

```
<div id="app">
    <!--  
		注意:在指令中不要写插值语法  直接写对应的变量名称 
        在 v-text 中 赋值的时候不要在写 插值语法
		一般属性中不加 {{}}  直接写 对应 的数据名 
	-->
    <p v-text="msg"></p>
    <p>
        <!-- Vue  中只有在标签的 内容中 才用插值语法 -->
        {{msg}}
    </p>
</div>

<script>
    new Vue({
        el: '#app',
        data: {
            msg: 'Hello Vue.js'
        }
    });

</script>
```

##### v-html

###### 用法和v-text 相似  但是他可以将HTML片段填充到标签中

###### 可能有	安全问题, 一般只在可信任内容上使用 `v-html`，**永不**用在用户提交的内容上

###### 它与v-text区别在于v-text输出的是纯文本，浏览器不会对其再进行html解析，但v-html会将其当html标签解析后输出。

```
<div id="app">
　　<p v-html="html"></p> <!-- 输出：html标签在渲染的时候被解析 -->
    
    <p>{{message}}</p> <!-- 输出：<span>通过双括号绑定</span> -->
    
　　<p v-text="text"></p> <!-- 输出：<span>html标签在渲染的时候被源码输出</span> -->
</div>
<script>
　　let app = new Vue({
　　el: "#app",
　　data: {
　　　　message: "<span>通过双括号绑定</span>",
　　　　html: "<span>html标签在渲染的时候被解析</span>",
　　　　text: "<span>html标签在渲染的时候被源码输出</span>",
　　}
 });
</script>
```

##### v-bind

###### 用来绑定属性的机制

###### v-bind 指令被用来响应地更新 HTML 属性

###### v-bind:href  可以缩写为    :href;

###### v-bind中可以写合法的JS表达式

```
<body>
    <div id="app">
        <input type="button" value="按扭" v-bind:title="mytitle + '123'">
        <input type="button" value="按扭" :title="mytitle + '的简写形式'">
    </div>

</body>
<script src="./vue.js"></script>
<script>
    var app = new Vue({
        el: '#app',
        data: {
            mytitle: '这是我自己定义的title'
        }
    });
</script>
```

##### v-on

###### 用来绑定事件的机制

###### 如果在元素指定处理函数中加了小括号()，就可以给函数传参数.

```
<body>
    <div id="app">
        <input type="button" value="按扭" :title="mytitle + '的简写形式'" v-on:click='show'>
        <input type="button" value="按扭" :title="mytitle + '的简写形式'" @click='show'>
    </div>
</body>
<script src="./vue.js"></script>
<script>
    var app = new Vue({
        el: '#app',
        data: {
            mytitle: '这是我自己定义的title',
        },
        methods: {  //这个属性定义了当前vue实例所有可用的方法
            show: function () {
                alert('hello word');
            }
        }
    });


</script>
```

#### 事件修饰符

###### .stop  取消事件的冒泡

###### .prevent 取消默认事件

###### .capture 事件的捕获（从外往内）

###### .self 点击当前元素的时候，才会触发事件处理函数（只会阻止自身冒泡行为的触发，并不会阻止其它的元素）

###### .once 只触发一次的函数

```
<body>
    <div id="app">
        <div class="inner" @click.capture.self="divHandle">
            <input type="button" value="阻止冒泡" @click.stop='btnHandle'>
            <a title="阻止默认行为" href="http://www.baidu.com" @click.prevent.once='prevHandle'>我是百度</a>
        </div>
    </div>
</body>
<script src="./vue.js"></script>
<script>
    var app = new Vue({
        el: '#app',
        data: {

        },
        methods: {
            divHandle() {
                console.log('事件捕获');
            },
            btnHandle() {
                console.log('btnHandle');
            },
            prevHandle() {
                console.log("百度");
            }
        }
    });
</script>
```

##### v-model 

###### 双向数据绑定

###### **v-model**是一个指令，限制在 `<input>、<select>、<textarea>、components`中使用

```
<body>

    <div id="app">
        <h4>{{msg}}</h4>
        <input type="text" v-model='msg' style="width: 100%">
    </div>

</body>
<script src="./vue.js"></script>
<script>
    var vm = new Vue({
        el: '#app',
        data: {
            msg: '魂牵梦萦'
        }
    });
</script>
```

#### 在Vue中使用样式

##### 使用class样式

###### 数组

###### 注意：这里的class需要使用v-bind做数据绑定

```
<style>
    .red {
        height: 150px;
        background-color: red;
    }

    .think {
        font-weight: 200;
    }
    .italic {
        font-style: italic;
    }
    .active {
        letter-spacing: 1rem;
    }
</style>

<body>
    <div id="app">
        <!-- 使用数组的方式，三元表达式 -->
        <h1 :class="['red', 'think', flag ? 'active': '']">这是一个很大很大的H1</h1>
        <!-- 使用数组对象的方式 -->
        <h1 :class="['red', 'think', {'active': flag}]">这是一个很大很大的H1</h1>
        <!-- 使用对象的方式 -->
        <h1 :class="{red: true, think: true, active: false}">这是一个很大很大的H1</h1>
        <h1 :class="classObj">这是一个很大很大的H1</h1>
    </div>

</body>
<script src="./vue.js"></script>
<script>
    var vm = new Vue({
        el: '#app',
        data: {
            flag: true,
            classObj: {red: true, think: true, active: false}
        }
    });
</script>
```

##### 使用内联样式

###### 注意：这里的class需要用v-bind来绑定

###### 如果对象中属性名有（-）号，必须要加引号，也可以使用小驼峰的写法就不用加引号

```
<body>
    <div id="app">
        <h1 :style="{color: 'red', 'font-weight': 200}">这是一个h1</h1>
        <h1 :style='styleObj1'>这是一个h1</h1>
        <h1 :style='[styleObj1, styleObj2]'>这是一个h1</h1>
    </div>

</body>
<script src="./vue.js"></script>
<script>
    var vm = new Vue({
        el: '#app',
        data: {
            styleObj1: {color: 'red', 'font-weight': 200},
            styleObj2: {height: '200px', backgroundColor: 'blue'}
        }
    });
</script>
```

#### v-for的四种使用方式

```
<body>
    <div id="app">
        <!-- 循环数组 -->
        <p v-for="item in list">{{item}}</p>
        <p v-for="(item, index) in list">每一项：{{item}} ——— 索引值：{{index}}</p>
        <!-- 循环数组对象 -->
        <p v-for='item in list2'>{{item.id}} --- {{item.name}	}</p>
        <p v-for='(item, index) in list2'>{{item.id}} --- {{item.name}} 索引：{{index}}</p>
        <!-- 循环对象 -->
        <p v-for='(value, key) in list3'>属性值：{{value}} 属性名：{{key}}</p>
        <p v-for='(value, key, index) in list3'>属性值：{{value}} 属性名：{{key}} 索引：{{index}}</p>
        <!-- 迭代数字 -->
        <p v-for='count in 10'>这是第{{count}}循环</p>
    </div>

</body>
<script src="./vue.js"></script>
<script>
    var vm = new Vue({
        el: '#app',
        data: {
            list: [1,431,43124,314,3143,12],
            list2: [
                {id: 1, name: 'zs'},
                {id: 2, name: 'zs'},
                {id: 3, name: 'zs'},
                {id: 4, name: 'zs'}
            ],
            list3: {
                id: 1,
                name: 'ppp',
                sex: 'male'
            }
        }
    });
</script>
```

#### v-for中key的使用注意事项

###### 注意：v-for 循环的时候，key属性只能使用 number获取string

###### 注意：key在使用的时候，必须使用v-bind属性绑定的形式，指定key的值

###### 在组件中，使用v-for循环的时候，或者在一些特殊情况中， 如果v-for有问题，必须在使用v-for的同时，指定唯一的字符串/数字类型:key值

```
   <body>
   <div id="app">
        <div>
            <label for="">
                Id: <input type="text" v-model='id'>
            </label>
            <label for="">
                Name：<input type="text" v-model='name'>
            </label>
            <input type="button" value="添加" @click='add'>
        </div>

        <p v-for="item in list" :key='item.id'><input type="checkbox">{{item.id}}----{{item.name}}</p>
    </div>
</body>
<script src="./vue.js"></script>
<script>
    var vm = new Vue({
        el: '#app',
        data: {
            list: [
                {id: 1, name: 'ppp'},
                {id: 2, name: 'ddd'},
                {id: 3, name: 'kkk'}
            ],
            id: '',
            name: ''
        },
        methods: {
            add() {
                this.list.push({id: this.id, name: this.name});
            }
        }
    });
</script>
```

#### v-if和v-show的使用和特点

###### v-if的特点：每次都会重新删除或创建元素，切换的性能消耗较大（建议元素永远不出现时使用）

###### v-show的特点：切换元素的display的状态，初始渲染的消耗较大（建议元素频繁切换时使用）

```
<body>
    <div id="app">
        <input type="button" @click='flag=!flag' value="toggle">

        <h1 v-if='flag'>这是用v-if控制的元素</h1>
        <h1 v-show='flag'>这是用v-show控制的元素</h1>
    </div>
</body>
<script src="./vue.js"></script>
<script>
    var vm = new Vue({
        el: '#app',
        data: {
           flag: true
        },
        methods: {
            toggle() {
                this.flag = !this.flag;
            }
        }
    });
</script>
```

#### 过滤器

###### 概念：Vue.js允许你自定义的过滤器，可被用作一些常见的文本格式化，过滤器可以用在两个地方，mustache插值和v-bind表达式，过滤器应该被添加在JavaScript表达式的尾部，由"管道"符指示

##### 过滤器的定义语法

###### 过虑器的第一个参数是固定死的，永远都是过滤器管道符前面传递过来的数据

###### 可以传一个或多个参数，可多次调用过滤器

```
        Vue.filter('timeFormat', function (dataStr, pattern) {
            var time = new Date(	dataStr);
        var y = time.getFullYear();
        var m = time.getMonth() + 1;
        var d = time.getDate();
        var hh = time.getHours();
        var mm = time.getMinutes();
        var ss= time.getSeconds();
        if (pattern && pattern.toLowerCase() === 'yyyy-mm-dd') {
            return `${y}-${m}-${d}`;
        } else {
            return `${y}-${m}-${d} ${hh}:${mm}:${ss}`;
        }
    });
```

##### Vue的生命周期

```
<body>
    <div id="app">
        <input type="button" value='修改' @click="msg='修改完毕'">
        <h3 id='h3'>{{msg}}</h3>
    </div>
</body>
<script src="./vue.js"></script>
<script>

    var vm = new Vue({
        el: '#app',
        data: {
            msg: '执行完毕'
        },
        methods: {
            show() {
                console.log('show');
            }
        },
        beforeCreate() { //1，表示实例完全被创建出来之前，会执行它 
            // 在beforeCreate生命周期函数执行的时候，data和methods中的数据都还没有被初始化
            console.log(this.msg);
            this.show();
        },
        created() { //2
            // 在created中，data和methods都已经被初始化完成
            console.log(this.msg);
            this.show();
        },
        beforeMount() { //3
            // 把Vue代码中的那些指令进行执行，最终，在内存中生成一个编译好的最终模板字符串，渲染为内存中的DOM，并未渲染到页面中!
            console.log(document.getElementById('h3').innerText);
        },
        mounted() { // 4
            // 将内存中的DOM渲染到页面中!Vue实例已经初始化完毕;
            console.log(document.getElementById('h3').innerText);
        },
        //组件运行阶段的函数：会根据data数据的改变，有选择性的触发0到多次
        beforeUpdate() { //data数据更新后执行 虚拟内存的DOM树和data中的数据保持同步，但未渲染到DOM页面中！ data(Model)到view(视图层)
            console.log("页面上的元素：" + document.getElementById('h3').innerText);
            console.log("data中的msg数据是：" + this.msg);
        },
        updated() {  //data数据已渲染到页面中
            console.log("页面上的元素：" + document.getElementById('h3').innerText);
            console.log("data中的msg数据是：" + this.msg);
        },
        beforeDestroy() { //当前函数的data和所有的methods，以及过滤器、指令......都处于可用状态，此时实例还未真正被销毁 
            
        },
        destroyed() { //data和所有的数据、指令、过滤器....都被销毁
            console.log(this.msg);
        }
    });
</script>
```

#### vue-resource或axios发起get，post，jsonp请求  

###### 注意：vue-resource依赖于vue

###### 挂载了一些方法 this.$http

```
<body>
    <div id="app">
        <input type="button" value='get请求' @click='getInfo'>
        <input type="button" value='post请求' @click='postInfo'>
        <input type="button" value="jsonp请求" @click='jsonInfo'>
    </div>
</body>
<script src="./vue.js"></script>
<!-- 注意vue依赖于vue -->
<script src="./vue-resource.js"></script>
<script>
    var vm = new Vue({
        el: '#app',
        data: {
        },
        methods:{
            getInfo() { //发起get请求
                this.$http.get('http://jsonplaceholder.typicode.com/users').then(function (result) {
                    //通过retsult.body拿到服务的数据
                    console.log(result.body);
                });
            },
            postInfo() {
                //手动发起的post请求没有表单格式，所以有些服务器处理不了
                this.$http.post("http://jsonplaceholder.typicode.com/users", {}, {
                    emulateJSON: true
                }).then(result => {
                    console.log(result.body);
                })
            },
            jsonInfo() { //发起JSON
                this.$http.jsonp('http://jsonplaceholder.typicode.com/users').then(result=> {
                    console.log(result.body)
                })
            }
        }
    })
</script>
```

#### jsonp的实现原理

###### 由于浏览器的安全性限制，不允许AJAX访问，协议不同、域名不同、端口不同的数据接口，浏览器认为这种访问不安全

###### html页面

```
<script>
function show(data) {
        console.log(data);
    }
</script>
<script src="http://127.0.0.1:3000/getscript?callback=show"></script>
```

###### node页面

```
const http = require('http');
//解析url地址解析
const urlModule = require('url');

const server = http.createServer();

server.on('request', function (req, res) {
    console.log('收到请求');
    // const url = req.url;
    const {pathname: url, query} = urlModule.parse(req.url, true);
    if(url === '/getscript') {

        var data = {
            name: '小米',
            age: '18',
            sex: 'male'
        }

        //拼接一个合法的js脚本  
        var scriptStr = `${query.callback}(${JSON.stringify(data)})`;



        res.end(scriptStr);
    }else{
        res.end('404');
    }
});

server.listen(3000, function () {
    console.log('服务器启动成功');
});
```

##### 品牌列表-从数据库获取列表

###### html页面

```
<body>
    <div id="app">
        <div class="panel panel-primary">
            <div class="panel-heading">
                <h3 class="panel-title">品牌案例</h3>
            </div>
            <div class="panel-body form-inline">
                <label for="">
                    Name：
                    <input type="text" class="form-control" v-model='name'>
                </label>
                <label for="">
                    <input type="button" class="btn btn-primary" value='添加' @click='getAllList'>
                </label>
                <label for="">
                    搜索关键字：
                    <input type="text" class="form-control">
                </label>
            </div>
        </div>
        <table class="table table-bordered table-hover table-striped">
            <thead>
                <tr>
                    <th>ID</th>
                    <th>Name</th>
                    <th>Ctime</th>
                    <th>Operation</th>
                </tr>
            </thead>
            <tbody>
                <tr v-for='item in list'>
                    <td>{{item.id}}</td>
                    <td>{{item.name}}</td>
                    <td>{{item.ctime}}</td>
                    <td> <a href="javascript:void(0)">删除</a></td>
                </tr>
            </tbody>
        </table>
    </div>
</body>
<script src="./vue.js"></script>
<!-- 注意vue依赖于vue -->
<script src="./vue-resource.js"></script>
<script>

    var vm = new Vue({
        el: '#app',
        data: {
            id: '0',
            name: '',
            list: [
                { id: 1, name: '宝马', ctime: new Date() }
            ]
        },
        created() { //data数据和methods初始化完毕后
            this.getAllList();
        },  
        methods: {
            add() {

            },
            getAllList() { //获取所有的车的列表
                this.$http.get('http://127.0.0.1:3000/products').then(function (result) {
                    if(result.body.status === 0) {
                        console.log('成功');
                        this.list = result.body.message;
                    }else{
                        console.log('失败')
                    }
                });
            }
        }
    });

</script>
```

###### node页面

```
const http = require('http');

//解析url地址解析
const urlModule = require('url');

const server = http.createServer();

server.on('request', function (req, res) {
    console.log('收到请求');
    // const url = req.url;
    // res.writeHead(200, { 'Content-type': 'text/html;charset=utf-8' });
    // 解决跨域的问题
    res.writeHead(200, {'Content-Type': 'text/html;charset=utf-8', 'Access-Control-Allow-Origin': '*'}); 
    const { pathname: url, query } = urlModule.parse(req.url, true);
    if (url === '/products') {
        var data = {
            status: 0,
            message: [
            {
                id: 1,
                name: '宝马',
                ctime: new Date()
            },
            {
                id: 2,
                name: '奔驰',
                ctime: new Date()
            },
            {
                id: 3,
                name: '奥迪',
                ctime: new Date()
            }
        ]}
        //拼接一个合法的js脚本  
        var scriptStr = `${JSON.stringify(data)}`;

        res.end(scriptStr);
    } else {
        res.end('404');
    }
});
server.listen(3000, function () {
    console.log('服务器启动成功');
});
```

##### 完成添加后台数据功能

###### html页面

```
<script>

    var vm = new Vue({
        el: '#app',
        data: {
            id: '',
            name: '',
            list: []
        },
        created() { //data数据和methods初始化完毕后
            this.getAllList();
        },
        methods: {
            add() {//添加品牌列表到后台服务器
                // pos('请求的url地址', '要提交给服务器的数据对象', '配置对象，要以哪种表单数据类型提交过去')
                if (this.name.replace(/s+/g, '')) {
                    this.$http.post('http://127.0.0.1:3000/products', { name: this.name }, { emulateJSON: true })
                        .then(result => {
                            if (result.body.status === 0) {
                                //获取成功调用get方法，重新渲染到页面中
                                this.getAllList();
                                // this.name = '';
                            } else {
                                alert('添加失败');
                            }
                        });
                }
            },
            getAllList() { //获取所有的车的列表
                this.$http.get('http://127.0.0.1:3000/products').then(result => {
                    if (result.body.status === 0) {
                        console.log('成功');
                        this.list = result.body.message;
                    } else {
                        console.log('失败')
                    }
                });
            },

        }
    });

</script>
```

###### node页面

```
const http = require("http");
const urlModule = require('url');

//全局数据
let data = [];

data.push({id: 1, name: '宝马', ctime: new Date()});
data.push({id: 2, name: '奔驰', ctime: new Date()});
data.push({id: 3, name: '奥迪', ctime: new Date()});

//创建服务
var server = http.createServer();

server.on('request', function (request, response) {
    const {pathname: url, query} = urlModule.parse(request.url);

    if(url === '/products') {
        response.writeHead(200, {
            "Content-Type": "application/json;charset=utf-8",
            "Access-Control-Allow-Origin": "*"
        });
        //以POST请求，则加入数据
        if(request.method === "POST") {
            request.setEncoding("utf-8");
            let str = "";
            request.on("data", function (res) {//表示请求发送了数据
                str += res;
            });
            request.on("end", function () { //表示请求的数据发送完成
                let requestData = decodeRequestBody(request.headers["content-type"], str);
                data.push({ //加入数据
                    id: data.length + 1,
                    name: requestData.name,
                    ctime: new Date()
                });
                response.end(JSON.stringify({
                    status: 0,
                    message: data
                }))
            })
        }else if(request.method === 'GET') {
            //以GET请求，则返回数据
            response.end(JSON.stringify({
                status: 0,
                message: data
            }));
        }else{
            response.writeHead(404, {
                "Content-Type": "application/json;charset=utf-8",
                "Access-Control-Allow-Origin": "*"
            });
            response.end("{\"code\": 404}");
        }
    }
});
function decodeRequestBody(contentType, str) {
    let requestData = {};

    //说明请求数据体是 form-urlencoded 格式
    if(contentType.indexOf("form-urlencoded") > -1) {
        if(str) {
            let kvs = str.split('&');
            for(let i = 0; i < kvs.length; i ++) {
                let kv = kvs[i].split('=');
                requestData[kv[0]] = decodeURIComponent(kv[1]);
            }
        }
    }else if(contentType.indexOf("json") > -1) {
        requestData = JSON.parse(str);
    }
    return requestData;
}

server.listen(3000, function () {
    console.log('成功');
});
```

##### 完成删除功能

###### html页面

```
<body>
    <div id="app">
        <div class="panel panel-primary">
            <div class="panel-heading">
                <h3 class="panel-title">品牌案例</h3>
            </div>
            <div class="panel-body form-inline">
                <label for="">
                    Name：
                    <input type="text" class="form-control" v-model='name'>
                </label>
                <label for="">
                    <input type="button" class="btn btn-primary" value='添加' @click='add'>
                </label>
            </div>
        </div>
        <table class="table table-bordered table-hover table-striped">
            <thead>
                <tr>
                    <th>ID</th>
                    <th>Name</th>
                    <th>Ctime</th>
                    <th>Operation</th>
                </tr>
            </thead>
            <tbody>
                <tr v-for='item in list'>
                    <td>{{item.id}}</td>
                    <td>{{item.name}}</td>
                    <td>{{item.ctime}}</td>
                    <td> <a href="#" @click.prevent ="remove(item.id)">删除</a></td>
                </tr>
            </tbody>
        </table>
    </div>
</body>
<script src="./vue.js"></script>
<!-- 注意vue依赖于vue -->
<script src="./vue-resource.js"></script>
<script>

    var vm = new Vue({
        el: '#app',
        data: {
            id: '',
            name: '',
            list: []
        },
        created() { //data数据和methods初始化完毕后
            this.getAllList();
        },
        methods: {
            add() {//添加品牌列表到后台服务器
                // pos('请求的url地址', '要提交给服务器的数据对象', '配置对象，要以哪种表单数据类型提交过去')
                if (this.name.replace(/s+/g, '')) {
                    this.$http.post('http://127.0.0.1:3000/products', { name: this.name }, { emulateJSON: true })
                        .then(result => {
                            if (result.body.status === 0) {
                                //获取成功调用get方法，重新渲染到页面中
                                this.getAllList();
                                // this.name = '';
                            } else {
                                alert('添加失败');
                            }
                        });
                }
            },
            getAllList() { //获取所有的车的列表
                this.$http.get('http://127.0.0.1:3000/products').then(result => {
                    if (result.body.status === 0) {
                        console.log('成功');
                        this.list = result.body.message;
                    } else {
                        console.log('失败')
                    }
                });
            },
            remove(id) { //删除品牌
               this.$http.get("http://127.0.0.1:3000/products/" + id).then(result => {
                   if(result.body.status === 0) {
                       //删除成功
                       console.log("成功");
                       this.getAllList();
                   }else{
                       //删除失败
                       console.log("失败");
                   }
               })
            }   
        }
    });
</script>	
```

###### node页面

```
const http = require("http");
const urlModule = require('url');

//全局数据
let data = [];

data.push({ id: 1, name: '宝马', ctime: new Date() });
data.push({ id: 2, name: '奔驰', ctime: new Date() });
data.push({ id: 3, name: '奥迪', ctime: new Date() });


//创建服务
var server = http.createServer();

server.on('request', function (request, response) {
    const { pathname: url, query } = urlModule.parse(request.url);

    if (url === '/products' || (/\/\d+/g).test(url)) {
        response.writeHead(200, {
            "Content-Type": "application/json;charset=utf-8",
            "Access-Control-Allow-Origin": "*"
        });
        //以POST请求，则加入数据
        if (request.method === "POST") {
            request.setEncoding("utf-8");
            let str = "";
            request.on("data", function (res) {//表示请求发送了数据
                str += res;
            });
            request.on("end", function () { //表示请求的数据发送完成
                let requestData = decodeRequestBody(request.headers["content-type"], str);
                data.push({ //加入数据
                    id: data.length + 1,
                    name: requestData.name,
                    ctime: new Date()
                });
                response.end(JSON.stringify({
                    status: 0,
                    message: data
                }));
            })
        } else if (request.method === 'GET') {
            //以GET请求，则返回数据 
            var id = request.url.match(/(\d+)$/g) && request.url.match(/(\d+)$/g).toString();
            if (id) {
                var index = data.findIndex(item => {
                    if(item.id === id) {
                        return true;
                    }
                });
                data.splice(index, 1);
                response.end(JSON.stringify({
                    status: 0,
                    message: data
                }));

            } else {
                response.end(JSON.stringify({
                    status: 0,
                    message: data
                }));
            }
        } else {
            response.writeHead(404, {
                "Content-Type": "application/json;charset=utf-8",
                "Access-Control-Allow-Origin": "*"
            });
            response.end("{\"code\": 404}");
        }
    }
});
function decodeRequestBody(contentType, str) {
    let requestData = {};

    //说明请求数据体是 form-urlencoded 格式
    if (contentType.indexOf("form-urlencoded") > -1) {
        if (str) {
            let kvs = str.split('&');
            for (let i = 0; i < kvs.length; i++) {
                let kv = kvs[i].split('=');
                requestData[kv[0]] = decodeURIComponent(kv[1]);
            }
        }
    } else if (contentType.indexOf("json") > -1) {
        requestData = JSON.parse(str);
    }
    return requestData;
}

server.listen(3000, function () {
    console.log('成功');
});
```

##### 全局配置数据接口的根域名

```
 Vue.http.options.root = "http://127.0.0.1:3000/";
```

##### 全局启用emulateJSON选项

```
Vue.http.options.emulateJSON = true;
```

#### Vue中的动画

##### 过渡

###### 自定义v-前缀

```

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Vue</title>
    <link rel="stylesheet" href="bootstrap-3.1.1-dist/css/bootstrap.css">
    <style>
        /* 初始前，离开后 */
        .v-enter,
        .v-leave-to {
            opacity: 0;
            transform: translateX(150px);
        }

        /* 过滤时间段 */
        .v-enter-active,
        .v-leave-active {
            transition: all 0.4s ease;
        }

        /* 初始后，离开前 */
        .v-enter-to,
        .v-leave {
            opacity: 1;

        }

        /* 初始前，离开后 */
        .my-enter,
        .my-leave-to {
            opacity: 0;
            transform: translateY(150px);
        }

        /* 过滤时间段 */
        .my-enter-active,
        .my-leave-active {
            transition: all 0.4s ease;
        }
    </style>
</head>
<body>
    <div id="app">
        <input type="button" class="btn btn-primary" value="toggle" @click='flag = !flag'>
        <!-- 动画组件 transition -->
        <transition>
            <h3 v-if='flag'>这是一个小的动画</h3>
        </transition>
        <hr>
        <input type="button" class="btn btn-primary" value="toggle" @click='flag2 = !flag2'>
        <transition name='my'>
            <h3 v-if='flag2'>这是一个小的动画</h3>
        </transition>
    </div>
</body>
<script src="./vue.js"></script>
<script>
    var vm = new Vue({
        el: '#app',
        data: {
            flag: true,
            flag2: true
        },
        methods: {

        }
    });

</script>

```

##### 使用第三文animate.css类库实现动画

```
<body>
    <div id="app">
        <input type="button" class="btn btn-primary" value="toggle" @click='flag = !flag'>
        <!-- 动画组件 transition -->
        <transition enter-active-class="bounceIn" leave-active-class='bounceOut' :duration="200">
            <h3 v-if='flag'>这是一个小的动画</h3>
        </transition>

        <input type="button" class="btn btn-primary" value="toggle" @click='flag = !flag'>
        <!-- 动画组件 transition -->
        <transition enter-active-class="bounceIn" leave-active-class='bounceOut' :duration="{enter: 200, leave: 400}">
            <h3 v-if='flag'>这是一个小的动画</h3>
        </transition>
    </div>
</body>
<script src="./vue.js"></script>
<script>
    var vm = new Vue({
        el: '#app',
        data: {
            flag: true,
        },
        methods: {

        }
    });
</script>
```

##### 钩子函数实现半场动画

```
<body>
    <div id="app">
        <input type="button" class="btn btn-primary" value="加入购物车" @click='flag = !flag'>
        <transition v-on:before-enter="beforeEnter" v-on:enter="enter" v-on:after-enter="afterEnter">
            <div class="ball" v-show='flag'></div>
        </transition>
    </div>
</body>
<script src="./vue.js"></script>
<script>
    var vm = new Vue({
        el: '#app',
        data: {
            flag: false,
        },
        methods: { 
            //动画钩子函数的第一个参数指当前dom对象
            //第二个参数指的是下一个钩子函数的引用
            beforeEnter(el) { //动画开始之前
                el.style.transform = "translate(0, 0)";
                
            },
            enter(el, done) {
                //过滤效果的设置
                el.offsetWidth;

                let h = window.innerHeight;
                el.style.transform = `translate(150px, ${h-50}px)`;
                el.style.transition = 'all 1s ease';
                done();
            },  
            afterEnter(el) {//动画完成后
                this.flag = !this.flag;
            }
        }
    });
</script>
```

##### 使用transition-group元素实现列表动画

```
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Vue</title>
    <link rel="stylesheet" href="bootstrap-3.1.1-dist/css/bootstrap.css">
    <link rel="stylesheet" href="./animate.css">

    <style>
        * {
            margin: 0;
            padding: 0;
        }

        li {
            border: 1px dashed #999;
            margin: 5px;
            line-height: 30px;
            padding-left: 10px;
        }
        li:hover{
            background-color: pink;
            transition: all .4s ease-out;
        }
        .v-enter,
        .v-leave-to {
            opacity: 0;
            transform: translateY(80px);
        }

        .v-enter-to,
        .v-leave {
            opacity: 1;
            transition: opacity .8s ease;
        }

        .v-move{
            transition: all .5s ease;
        }
        .v-leave-active{
            position: absolute;
            width: 100%;
        }
    </style>
</head>

<body>
    <div id="app">
        <label for="">
            Id:
            <input type="text" v-model='id'>
        </label>
        <label for="">
            Name:
            <input type="text" v-model='name'>
        </label>
        <input type="button" @click='add' value="添加">

        <!-- <ul> -->
            <!-- 实现v-for循环过渡的元素，使用transitionGroup --> 
            <!-- <ul appear属性实现页面入场动画效果 -->
            <!-- 设置tag属性为指定标签元素 -->
            <transition-group appear tag="ul">
                <li v-for='(item, index) in list' :key='item.id' @click='remove(index)'>{{item.id}}------{{item.name}}</li>
            </transition-group>
        <!-- </ul> -->
    </div>
</body>
<script src="./vue.js"></script>
<script>
    var vm = new Vue({
        el: '#app',
        data: {
            id: '',
            name: '',
            list: [
                { id: 1, name: '赵高' },
                { id: 2, name: '秦桧' },
                { id: 3, name: '严嵩' },
                { id: 4, name: '和绅' },
                { id: 5, name: '魏忠贤' },
            ]
        },
        methods: {
            add() {
                this.list.push({ id: this.id, name: this.name });
                this.name = this.id = '';
            },
            remove(id) {
                this.list.splice(id, 1);
            }
        }
    });
</script>
```

#### 组件化和模块化的区别

###### 注意点：定义时只能有一个根组件

##### 全局组件定义的三种方式

###### 第一种

```
//第一种
<body>
    <div id="app">
        <!-- 1 -->
        <my-col></my-col>  
        <!-- 2 -->
        <mycol></mycol>
    </div>
</body>
<script src="./vue.js"></script>
<script>
    //创建组件
    var col = Vue.extend({
        template: `<h3>这是使用Vue.extend创建的组件</h3>`, //展示的html结构
    });
    //注册组件
    Vue.component('myCol', col);  // 1
    Vue.component('mycol', col);  // 2
    var vm = new Vue({
        el: '#app',
        data: {},
        methods: {}
    });
</script>

//第二种
<body>
    <div id="app">
        <!-- 1 -->
        <my-col></my-col>
        <!-- 2 -->
        <mycol></mycol>
    </div>
</body>
<script src="./vue.js"></script>
<script>
    //全局组件
    Vue.component('myCol', Vue.extend({
        template: `<h3>这是使用Vue.extend创建的组件</h3>`, //展示的html结构
    }));
    Vue.component('mycol', Vue.extend({
        template: `<h3>这是使用Vue.extend创建的组件</h3>`, //展示的html结构
    }));
    var vm = new Vue({
        el: '#app',
        data: {},
        methods: {}
    });
</script>
```

###### 第二种

```
<body>
    <div id="app">
        <!-- 1 -->
        <my-col></my-col>
        <!-- 2 -->
        <mycol></mycol>
    </div>
</body>
<script src="./vue.js"></script>
<script>
    //全局组件
    Vue.component('mycol', {
        template: `<h3>这是直接使用Vue.component 创建出来的组件</h3>`
    });
    Vue.component('myCol', {
        template: `<h3>这是直接使用Vue.component 创建出来的组件</h3>`
    });

    var vm = new Vue({
        el: '#app',
        data: {},
        methods: {}
    });
</script>
```

###### 第三种

```
<body>
    <div id="app">
        <template id="temp1">
            <div>
                <h3>我是一个组件</h3>
            </div>
        </template>
    </div>
</body>
<script src="./vue.js"></script>
<script>
    //全局组件
    Vue.component('mycol', {
        template: '#temp1'
    });
    var vm = new Vue({
        el: '#app',
        data: {},
        methods: {}
    });
</script>
```

##### 定义私有组件

```
<body>
    <div id="app">
        <login></login>
        <template id='temp'>
            <div>
                <h1>我是一个标签</h1>
            </div>
        </template>
    </div>
</body>
<script src="./vue.js"></script>
<script>
    //私有组件
    var vm = new Vue({
        el: '#app',
        data: {},
        methods: {},
        filters: {},
        directives: {},
        components: { 
            login: {
                template: `<h1>我是一个标签</h1>`
            },
            temp: {
                template: `#temp`
            }
        },
        beforeCreate() {},
        created() {},
        beforeMount() {},
        mounted() {},
        beforeUpdate() {},
        updated() {},
        beforeDestroy() {},
        destroyed() {}
    });
</script>
```

##### 组件中的data

###### data必须是一个函数，必须返回一个对象

```
<body>
    <div id="app">
        <mycol></mycol>
    </div>
</body>
<script src="./vue.js"></script>
<script>

    Vue.component('mycol', {
        template: `<h3>这是全局组件----- {{msg}}</h3>`,
        data: function () {
            return {
                msg: '组件中的data定义的数据'
            }
        }
    });

    //全局组件
    var vm = new Vue({
        el: '#app',
        data: {},
        methods: {}
    });
</script>
```

##### 为什么组件中的data必须是个function

```
<body>
    <template id="temp">
        <div>
            <input type="button" value="add" @click="increment">
            <h3>{{count}}</h3>
        </div>
    </template>
    <div id="app">
        <counter></counter>
        <hr>
        <counter></counter>
    </div>

</body>
<script src="./vue.js"></script>
<script>

    //这是一个计数器的组件
    Vue.component('counter', {
        template: '#temp',
        data: function () {
            return {count: 0}
        },
        methods: {
            increment() {
                this.count++;
            }
        }
    });
    var vm = new Vue({
        el: '#app',
        data: {},
        methods: {}
    });
</script>
```

##### 组件切换

```
<body>
    <div id="app">
        <a href="javascript:void(0)" @click="flag=true">登录</a>

        <a href="javascript:void(0)" @click="flag=false">注册</a>

        <login v-if='flag'></login>
        <register v-else='flag'></register>
    </div>
</body>
<script src="./vue.js"></script>
<script>
    Vue.component('login', {		
        template: '<h3>登录组件</h3>'
    });
    Vue.component('register', {
        template: `<h3>注册组件</h3>`
    });
    //全局组件
    var vm = new Vue({
        el: '#app',
        data: {
            flag: true
        },
        methods: {}
    });
</script>
```

##### 使用Vue提供的component元素实现组件切

```
<body>
    <div id="app">
        <a href="javascript:void(0)" @click='comName="login"'>登录</a>
        <a href="javascript:void(0)" @click='comName="register"'>注册</a>
        <component :is="comName"></component>
    </div>
</body>
<script src="./vue.js"></script>
<script>
    Vue.component('login', {
        template: '<h3>登录组件</h3>'
    });
    Vue.component('register', {
        template: `<h3>注册组件</h3>`
    });
    //全局组件
    var vm = new Vue({
        el: '#app',
        data: {
            comName: 'login'
        },
        methods: {}
    });
</script>
```

##### 应用切换动画和mode方式

```
<body>
    <div id="app">
        <a href="javascript:void(0)" @click='comName="login"'>登录</a>
        <a href="javascript:void(0)" @click='comName="register"'>注册</a>
        <!-- 通过mode属性，设置组件切换时候的模式 -->
        <transition mode="out-in">
            <component :is="comName"></component>
        </transition>
    </div>
</body>
<script src="./vue.js"></script>
<script>
    Vue.component('login', {
        template: '<h3>登录组件</h3>'
    });
    Vue.component('register', {
        template: `<h3>注册组件</h3>`
    });
    //全局组件
    var vm = new Vue({
        el: '#app',
        data: {
            comName: 'login'
        },
        methods: {}
    });
</script>
```

##### 父组件向子组件传值

###### 要通过v-bind这种形式来绑定！

###### 先在props数组中定义，才能使用父组件的值！并且props的数据都是只读的，无法重新赋值	·

```
<body>
    <div id="app">
        <login v-bind:msg="msg"></login>
    </div>
</body>
<script src="./vue.js"></script>
<script>
    var vm = new Vue({
        el: '#app',
        data: {
            msg: 'hello word'
        },
        methods: {},
        components: {
          login: {
              data() {
                  return {
                      title: '123',
                      content: 'qqq'
                  }
              },
              template: `<h3 @click="test">这是子组件-----{{msg}}</h3>`,
              props: ['msg'],
              methods: {
                  test() {
                      console.log('test');
                  }
              }
          }
        }
    });

</script>
```

##### 子组件通过事件调用向父组件传值

```
<body>
    <div id="app">
        <login @show='show'></login>
    </div>
    <template id='temp'>
        <div>
            <input type="button" value='子组件按扭' @click="show">
            <h1>我是子组件</h1>
        </div>
    </template>
</body>
<script src="./vue.js"></script>
<script>
    var login = {
        template: `#temp`,
        data() {
            return {
                sonmsg: {name: '小头儿子', age: 6}
            }
        },
        methods: {
            show(data) {
                //emit触发调用
                this.$emit('show', 123, 456);
                //取到当前子组件的msg值
                this.$emit('show', this.sonmsg.name, this.sonmsg.age)
            }
        }
    }
    var vm = new Vue({
        el: '#app',
        data: {
            datamsgFormSon: null
        },
        methods: {
            show(data, data2) {
                console.log('调用了父组件身上的 show方法 ---- ' + data +"----"+ data2);
                console.log(this.datamsgFormSon = data);
            }
        },
        components: {
            login
        }
    });
</script> 
```

##### 使用$ref获取DOM元素和组件引用

```
<body>
    <div id="app">
        <input type="button" value="获取元素" @click='getEl'>
       <h3 ref="h3">hello wrod</h3>
       <login ref='login'></login>
    </div>
    <template id='temp'>
        <div>
            <h2>登录</h2>
        </div>
    </template>
</body>
<script src="./vue.js"></script>
<script>

    var login = {
        template: '#temp',
        data() {
            return {
                msg: 'son msg'
            }
        },
        methods: {
            show() {
                console.log('son hello word')
            }
        }
    }

    var vm = new Vue({
        el: '#app',
        data: {
            
        },
        methods: {
          getEl() {
            console.log(this.$refs.login.msg);
            console.log(this.$refs.login.show())
          }
        },
        components: {
            login
        }
    });
</script>
```

#### Vue路由

###### 后端路由：对于普通的网站，所有的超链接都是URL地址，所有的URL地址对应服务器上对应的资源

###### 前端路由：对于单页面应用程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时hash有一个特点，HTTP请求中不会包含hash相关的内容，所以，单页面程序中的页面跳转主要由hash实现

###### 单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由（区别于后端路由）；

##### 基本使用

```
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Vue</title>
    <link rel="stylesheet" href="bootstrap-3.1.1-dist/css/bootstrap.css">
    <link rel="stylesheet" href="./animate.css">

    <style>
        * {
            margin: 0;
            padding: 0;
        }

        /*4. 设置选中路由高亮的两种方式 */
        .router-link-active,
        .myActive {
            color: red !important;
            font-weight: bolder;
        }

        .v-enter, .v-leave-to{
            opacity: 0;
            transform: translateX(140px);
        }
         .v-enter-active, .v-leave-active{
             transition: all .5s ease;
         }
    </style>
</head>

<body>
    <div id="app">
        <!-- 2. router-link的使用方式 -->
        <!-- router默认渲染为一个a标签 -->
        <!-- tag 自定义渲染标签元素 -->
        <router-link to='/login' tag='span'>登录</router-link>
        <router-link to='/register'>注册</router-link>
        <!-- 5.路由动画 -->
        <mode='out-in'> 
            <router-view></router-view>
        </transition>
    </div>

</body>
<script src="./vue.js"></script>
<script src='./vue-router.js'></script>
<script>
    var login = {
        template: `<h1>登录组件</h1>`
    }
    var register = {
        template: `<h1>注册组件</h1>`
    }

    // 1.构建路由
    var routerObj = new VueRouter({
        routes: [ //路由匹配规则
            //每个路由规则，都是一个对象！必须有两个属性!
            // 属性1：path，表示监听哪个路由链接地址
            // 属性2：是component，表示，如果路由是前面匹配到的path，则展示component属性对应的那个组件
            { path: '/', redirect: '/login' }, //3.redirect 重定向:页面刚进入显示的页面
            { path: '/login', component: login },
            { path: '/register', component: register }
        ],
        linkActiveClass: 'myActive'  //自定义默认选中路由的class类
    });

    var vm = new Vue({
        el: '#app',
        data: {
        },
        methods: {
        },
        router: routerObj  //将路由规则对象注册到vm实例
    });
</script>
```

##### 使用query的方式传递参数

```

<body>
    <div id="app">
        <!-- 1.路由传参-使用query的方式 -->
        <router-link to='/login?id=10&name=zs'>登录</router-link>
        <router-link to='/register'>注册</router-link>
        <router-view></router-view>
    </div>

</body>
<script src="./vue.js"></script>
<script src='./vue-router.js'></script>
<script>
    var login = {
        template: `<h1>登录---{{$route.query.id}}------{{$route.query.name}}</h1>`,
        data() {
            return {
                msg: 123
            }
        },
        created() {
            console.log(this);
        }
    }
    var register = {
        template: `<h1>注册</h1>`
    }

    var router = new VueRouter({
        routes: [
            {path: '/login', component: login},
            {path: '/register', component: register},
        ]
    });

   var vm = new Vue({
       el: '#app',
       data: {},
       methods: {},
       router,
   });
</script>

```

##### 使用params的方式传递参数

```
<body>
    <div id="app">
        <!-- 1.路由传参-使用params的方式 -->
        <router-link to='/login/12/ls'>登录</router-link>
        <router-link to='/register'>注册</router-link>
        <router-view></router-view>
    </div>

</body>
<script src="./vue.js"></script>
<script src='./vue-router.js'></script>
<script>
    var login = {
        template: `<h1>登录---{{$route.params.id}}------{{$route.params.name}}</h1>`,
        data() {
            return {
                msg: 123
            }
        },
        created() {
            console.log(this);
        }
    }
    var register = {
        template: `<h1>注册</h1>`
    }

    var router = new VueRouter({
        routes: [
            {path: '/login/:id/:name', component: login},
            {path: '/register', component: register},
        ]
    });

   var vm = new Vue({
       el: '#app',
       data: {},
       methods: {},
       router,
   });
</script>
```

##### 使用children属性实现路由嵌套

```
<body>

    <div id="app">
        <router-link to='/account'>Accout</router-link>
        <router-view></router-view>
    </div>

    <template id='teml'>
        <div>
            <h1>这是 Accout 组件</h1>
            <router-link to='/account/login'>登录</router-link>
            <router-link to='/account/register'>注册</router-link>
        </div>
    </template>

    <template id='login'>
        <div>
            <h3>登录</h3>
        </div>
    </template>
    
    <template id='register'>
        <div>
            <h3>注册</h3>
        </div>
    </template>
</body>
<script src="./vue.js"></script>
<script src='./vue-router.js'></script>
<script src='./vue-resource.js'></script>
<script>

    var account = {
        template: '#teml'
    }
    var login = {
        template: '#login'
    }
    var register = {
        template: '#login'
    }
    var router = new VueRouter({
        routes: [
            {
                path: '/account',
                component: account,
                children: [
                    //使用子路由的acuuout的路径不能带斜线
                    { path: 'login', component: login },
                    { path: 'register', component: register}
                ]
            },
        ]
    });
    var vm = new Vue({
        el: '#app',
        data: {

        },
        methods: {

        },
        router
    })
</script>
```

##### 路由—使用命名视图实现经典布局

```
<body>

    <div id="app">
        <router-view></router-view>
        <router-view name='left'></router-view>
        <router-view name='main'></router-view>
    </div>
</body>
<script src="./vue.js"></script>
<script src='./vue-router.js'></script>
<script src='./vue-resource.js'></script>
<script>
    var header = {
        template: '<h2>Header头部区域</h2>'
    }
    var leftBox = {
        template: '<h2>left区域</h2>'
    }
    var mainBox = {
        template: '<h2>主体区域</h2>'
    }

    var router = new VueRouter({
        routes: [
            {
                path: '/',
                components: {
                    default: header,
                    left: leftBox,
                    main: mainBox
                }
            },
        ]
    })
    var vm = new Vue({
        el: '#app',
        data: {},
        methods: {},
        router
    })
</script>
```

##### 父子组件传值复习

```
<body>
    <div id="app">
        <coml :sonmsg='parsentmsg' @func="getSonData"></coml>
    </div>

    <template id='temp'>
        <div>
            <h1>子元素----{{sonmsg}}</h1>
            <input type="button" value="向父组件传递消息" @click='sendMsg'>
        </div>
    </template>
</body>
<script src="./vue.js"></script>
<script src='./vue-router.js'></script>
<script src='./vue-resource.js'></script>
<script>
    
    var coml = {
        template: '#temp',
        props: ['sonmsg'],
        data() {
            return {
                msg: '子组件中的数据'
            }
        },
        methods: {
            sendMsg() {
                this.$emit('func', this.msg);
            }
        }
    }
    var vm = new Vue({
        el: '#app',
        data: {
            parsentmsg: '父组件的数据'
        },
        methods: {
            getSonData(data) {
                this.parsentmsg = data;
                console.log(this.parsentmsg);
            }
        },
        components: {
            coml
        }
    })
</script>
```

##### watch监视路由地址的改变

```
<body>

    <div id="app">
        <router-link to='/login'>登录</router-link>
        <router-link to='/register'>注册</router-link>
        <router-view></router-view>
    </div>
    <template id='login'>
        <div>
            <h3>登录</h3>
        </div>
    </template>
    <template id='register'>
        <div>
            <h3>注册</h3>
        </div>
    </template>
</body>
<script src="./vue.js"></script>
<script src='./vue-router.js'></script>
<script src='./vue-resource.js'></script>
<script>
    var login = {
        template: '#login'
    }
    var register = {
        template: '#register'
    }
    var router = new VueRouter({
        routes: [
            {path: '/', redirect: '/login'},
            { path: '/login', component: login },
            { path: '/register', component: register }
        ]
    })
    var vm = new Vue({
        el: '#app',
        data: {},
        methods: {},
        router,
        watch: {
            "$route.path": function (newValue, oldValue) {
                console.log(newValue + '------' + oldValue);
            }
        }
    });
</script>
```

##### nrm的使用

```
npm install nrm -g  //下载nrm

nrm ls //查看镜像地址

nrm user '你的镜像地址' //切换镜像地址
```

#### webpack

###### webpack是基于node.js开发出来的一个前端工具

##### webpack的基本使用方式

```
 webpack .\src\main.js .\dist\bundle.js  //webpack '打包前的文件路径' '打包后的文件路径'
```

##### webpack最基本的配置文本的使用

```
const path = require('path');

module.exports = {
    //入口打包的文件
    entry: path.join(__dirname, './src/main.js'),
    output: {//输出文件相关的配置
        path: path.join(__dirname, './dist'),
        filename: 'bundle.js' //指定输出文件的名称  
    }
}
```

##### webpack-dev-server的基本使用

###### npm intall webpack-dev-server -D  安装依赖包

###### 本地项目中安装webpack@3.6.0

##### webpack-dev-server的常用命令	

###### 在package.json文件中设置-

###### -open 自动打开浏览器

###### --port 300  自定义端口号

###### --contentBase src 自定义打开src下的index文件

###### --hot  热更新，不刷新浏览器页面

```
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "dev": "webpack-dev-server --open --port 3000 --contentBase src --hot" 
  },
```

##### webpack-dev-server配置命令的第二种方式

###### 在webapck.config.js中设置

```
//启用热更新2
const webpack = require('webpack');
module.exports = {
    //入口打包的文件
    entry: path.join(__dirname, './src/main.js'),
    output: {//输出文件相关的配置
        path: path.join(__dirname, './dist'),
        filename: 'bundle.js' //指定输出文件的名称  
    },
    devServer: { //这是配置 dev-server 命令参数的第二种形式，相对麻烦且好用
        open: true, //自动打开浏览器
        port: 3000,  //设置运行时的启动端口
        contentBase: 'src', //指定托管的根目录
        hot: true,  //启用热更新1
    },
    plugins: [
        new webpack.HotModuleReplacementPlugin() //new 一个热更新的模块对象 3
    ]
}
```

##### html-webpack-plugin的两个基本作用

###### 在webapck.config.js中设置

###### 自动在内存中根据指定页面生成一个内存的页面

###### 自动把打包好的bundle.js追加到页面中去

```
const path = require('path');

//启用热更新2
const webpack = require('webpack');

const htmlWebpackPlugin = require('html-webpack-plugin');
//只要是插件，都一定要放到plugins 节点中去
module.exports = {
    //入口打包的文件
    entry: path.join(__dirname, './src/main.js'),
    output: {//输出文件相关的配置
        path: path.join(__dirname, './dist'),
        filename: 'bundle.js' //指定输出文件的名称  
    },
    devServer: { //这是配置 dev-server 命令参数的第二种形式，相对麻烦且好用
        open: true, //自动打开浏览器
        port: 3000,  //设置运行时的启动端口
        contentBase: 'src', //指定托管的根目录
        hot: true,  //启用热更新1
    },
    plugins: [
        new webpack.HotModuleReplacementPlugin(), //new 一个热更新的模块对象 3
        new htmlWebpackPlugin({ //创建一个在内存中生成HTMLt生成的插件
            template: path.join(__dirname, './src/index.html'),
            filename: 'index.html'  //指定生成页面的名称
        })
    ]
}
```

##### 打包处理css文件

###### 在webpack.config.js配置 

###### 安装打包处理css文件	npm install style-loader css-loader -D

```
const path = require('path');

//启用热更新2
const webpack = require('webpack');

const htmlWebpackPlugin = require('html-webpack-plugin');
//只要是插件，都一定要放到plugins 节点中去
module.exports = {
    //入口打包的文件
    entry: path.join(__dirname, './src/main.js'),
    output: {//输出文件相关的配置
        path: path.join(__dirname, './dist'),
        filename: 'bundle.js' //指定输出文件的名称  
    },
    devServer: { //这是配置 dev-server 命令参数的第二种形式，相对麻烦且好用
        open: true, //自动打开浏览器
        port: 3000,  //设置运行时的启动端口
        contentBase: 'src', //指定托管的根目录
        hot: true,  //启用热更新1
    },
    plugins: [//配置插件的节点
        new webpack.HotModuleReplacementPlugin(), //new 一个热更新的模块对象 3
        new htmlWebpackPlugin({ //创建一个在内存中生成HTMLt生成的插件
            template: path.join(__dirname, './src/index.html'),
            filename: 'index.html'  //指定生成页面的名称
        })
    ],
    module: { //配置第三方模块加载器
        rules: [ //所有第三方模块的匹配规则 
            {test: /\.css$/, use: ['style-loader', 'css-loader']}, //配置处理.css文件的第三方loader规则模块
        ]
    }
}
```

##### webpack中url-loader的使用

```

```

##### webpack中babel的配置

###### 在main.js中设置

###### 识别更高级别的es6语法

###### 第一套包：cnpm intall babel-core babel-loader@7 babel-plugin-transform-runtime -D

###### 第二套包：cnpm install babel-preset-env babel-preset-stage-0 -D

###### 根目录新建一个.babelrc文件，配置如下

```
{
    "presets": ["env", "stage-0"],
    "plugins": ["transform-runtime"]
}
```

#### webpack结合Vue使用

##### 使用Vue实例的方法渲染组件 

```
<body>

    <div id="app">
      <p>fdsafsa</p>
    </div>
</body>
<script src="./vue.js"></script>
<script src='./vue-router.js'></script>
<script src='./vue-resource.js'></script>
<script>
    var login = {
        template: '<h3>登录组件</h3>'
    }

    var vm = new Vue({
        el: '#app',
        data: {},
        methods: {},
        computed: { //在computed中，可以定义

        },
        render: function (createElements) {
           return createElements(login);
        }
    });
</script>
```

##### webpack中导入vue和普通网页使用vue

###### cnpm install vue -S

```
//如果在webpack构建的项目中，使用vue进行开发
import Vue from 'vue'; || import Vue from '../node_modules/vue/dist/vue.js';
var vm = new Vue({
    el: '#app',
    data: {
        msg: 123
    },
    methods: {

    }
});
```

###### webpack.config.js文件下

```
    resolve: {
        alias: {
            "vue$": "vue/dist/vue.js"
        }
    }
```

##### 在vue中结合render函数渲染到指定的容器中

###### cnpm install vue-loader vue-template-compiler -D

##### webpack结合vue使用的总结

###### 安装vue的包：cnpm install vue -S

###### 由于在webpack中，推荐使用.vue这个组件模板定义组件，需要安装解析这种文件的包 cnpm install vue-loader vue-template-compiler -D

###### 在main.js中，导入vue模块 import Vue from 'vue'

###### 定义一个.vue结尾的组件，由三部分组成：template script style

###### 使用import导入这个组件，创建vm的实例 var vm = new Vue({el: '#app', render: c=> c(login)})

##### export default和export的使用方式

###### 在一个模块中export default 只允许暴露一次，export 可以暴露多个

###### 在一个模块中可以同时使用export default 和 export向外暴露成员

###### 使用export向外暴露的成员，只能使用{}的形式来接收，这种形式，叫做【按需导出】

###### export导出的名称可以用 as 来重新命名

##### 在webpack中使用路由

###### 安装vue-router的包  cnpm install vue-router -g

##### 组件中的style标签lang属性scoped属性的介绍

```
<style lang="scss" scoped> 
 /*设置lang: 使用scss的语法，scoped: 局部作用域*/
    div{
        color: red;
    }

</style>
```

##### 抽离路由

#### Mint-UI组件使用

######  npm install mint-ui -S

##### 按需导入

###### cnpm install babel-plugin-component -D

#### Promise

###### 封装一个读取文件的方法

```
function getFileByPath(fpath, succCd, errorCb) {
    fs.readFile(fpath, 'utf-8', (error, dataStr) => {
        if(error) {
           return errorCb(error);
        }
        return succCd(dataStr);
    })
}
getFileByPath(path.join(__dirname, './H5.html'), function (data) {
    console.log(data);
}, function (error) {
    console.log(error);
});
```

##### promise形式上的和具体的Promise异步操作的

```
var promise = new Promise(); //形式上的异步操作
var promise = new Promise(function () {}); //具体的异步操作
```

##### Promise的正确使用方式

###### 解决回调地狱

```
function getFileByPath(fpath) {
    return new Promise(function (resolve, reject) {
        fs.readFile(fpath, 'utf-8', (error, data) => {
            if (error) {
                return reject(error);
            }
            resolve(data);
        });
    });
}

getFileByPath('./H5.html')
    .then(function (data) {
        console.log(data);
        return getFileByPath('./Vue.html');
    })
    .then(function (data) {
        console.log(data);
        return getFileByPath('./js.html');
    })
    .then(function (data) {
        console.log(data);
    });
```

##### Promise捕获异常的两种方式

###### 第一种：前面的函数执行不成功，不影响后续的函数继续执行

```
function getFileByPath(fpath) {
    return new Promise(function (resolve, reject) {
        fs.readFile(fpath, 'utf-8', (error, data) => {
            if (error) {
                return reject(error);
            }
            resolve(data);
        });
    });
}
getFileByPath('./5.html')
    .then(function (data) {
        console.log(data);
        return getFileByPath('./Vue.html');
    }, function (error) {
        console.log('这是失败的结果' + error.message);
        return getFileByPath('./Vue.html');
    })
    .then(function (data) {
        console.log(data);
        return getFileByPath('./js.html');
    })
    .then(function (data) {
        console.log(data);
    });
```

###### 第二种：前面的函数执行不成功，后面的函数停止执行

```
function getFileByPath(fpath) {
    return new Promise(function (resolve, reject) {
        fs.readFile(fpath, 'utf-8', (error, data) => {
            if (error) {
                return reject(error);
            }
            resolve(data);
        });
    });
}
getFileByPath('./H5.html')
    .then(function (data) {
        console.log(data);
        return getFileByPath('./ue.html');
    })
    .then(function (data) {
        console.log(data);
        return getFileByPath('./js.html');
    })
    .then(function (data) {
        console.log(data);
    }).
    catch(function (error) { //如果前面有错误就终止后续代码的执行
        console.log(error.message);
    });
```

##### jQuery中使用ajax使用promise

```
    $(function () {
        $('#btn').on('click', function () {
            $.ajax({
                url: './data.json',
                type: 'get',
                dataType: 'json',
                success: function (data) {
                    // console.log(data);
                }
            })
            .then(function (data) {
                console.log(data);
            })
        })
    }) 
```

#### Vuex

Vuex是一个专门为Vue.js应用程序开发的状态管理模式，它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化 。Vuex也集成到Vue的官方调试工具devtools extension,提供了诸如雾配置的time-travel调试、状态快照导入导出等高级调试功能。

###### 全局共享的数据放到vuex中

###### 组件内部私有的数据，放到组件中的data中即可

###### cnpm install vuex -S

```
import Vuex from 'vuex';
Vue.use(Vuex);

//全局的vuex数据 调用vuex数据时，通过$store.state.count访问。修改state中的数据时，必须要通过mutattions方法调用
var store = new Vuex.Store({
    state: {    // this.$store.state ***

    },
    mutations: { //mutations中的函数参数只能支持两个参数 通过this.$store.commit("方法的名称")调用
       
    },
    getters: {
        
    }
})
```

